(8)

                           SKIP LIST    insert



                                insert 20
Maintain a navigation stack that stores the predecessor and successor node
pointers of each inserted node, which is generally a dynamic array
stack = [ [8,  NULL],
          [11, 21],
          [11, 21],
          [19, 21] ]


                  ..............>
Navigation LEVEL4 ──────────────> 8 ─────────────────────────*──────────────────────
   list                          .│                          ^
                                 .│                          ┃
                                 vv ............>            ┃
Navigation LEVEL3 ──────────────> 8 ────────────> 11 ────────*─> 21 ────────────────
   list                           │              .│          ^   │
                                  │              .│          ┃   │
                                  v              vv          ┃   v
Navigation LEVEL2 ─────> 1 ─────> 8 ───> 10 ────> 11 ────────*─> 21 ────────────────
   list                  │        │      │       .│          ^   │
                         │        │      │       .│          ┃   │
                         v        v      v       vv          ┃   v
Data List  LEVEL1 ─0───> 1 ──>4 ─>8 ───> 10 ────> 11 ──> 19 ─*─> 21───>30───────────
                                                             ^
                                                             │
                                                             20
    Start updating the navigation nodes:
        Suppose we landed heads on the third flip! LEVEL 4 first allocates a
        new node. Its down pointer points to the LEVEL 3 node 20, which has a
        value of 20. No other data is needed. The right pointer of the LEVEL 4
        PRE node stored in the stack points to the new node. The right pointer
        of the new node points to AFTER. Since AFTER is NULL, it simply points
        to NULL, indicating that there are no more nodes after it.
